# QP8 Widget Platform Shell

Проект Shell обеспечивает:
• загрузку структуры сайта QP8.WidgetPlatform c помощью WebAPI;
• создание внутреннего роутинга на основе структуры сайта;
• серверный рендеринг (SSR);
• загрузку параметров виджетов и страниц из WebAPI виджетной платформы;
• подгрузку удаленных модулей по технологии Webpack Module Federation;
• возможность получения данных из QP подключенными проектами типа Module через технологию GraphQL;
• возможность подключения сколь угодно большого числа проектов типа Module.

> *Здесь и далее описывается функционал, наcтроенный в шаблоне по умолчанию. Вы в праве расширить или изменить набор функций шаблона в соответствии с нуждами конкретного проекта.*

## Глоссарий

**Shell** – обертка структуры сайта. Shell загружает структуру сайта виджетной платформы QP c помощью WebAPI, создает структуру сайта на React Router и обеспечивает асинхронную загрузку параметров виджетов (в случае необходимости). Содержит в себе Apollo Client для взаимодействия с контентами QP.
**Module** – проект, включающий компоненты (визуальное представление) для отдельных типов страниц и виджетов в виджетной платформе на основе QP.
**Shell-core** – содержит в себе код бизнес-логики для проекта Shell. Для более простого обновления и доработки бизнес-логики выделен отдельный NPM-пакет.
**Bridge** – проект, предназначенный для передачи данных от проекта Shell проекту Module через React Context.
**Client/Клиент (режим работы на клиенте)** – выполнение уже собранных webpack-ом скриптов на стороне браузера.
**Server-Side Rendering (SSR)** – процесс рендеринга HTML на стороне сервера.
**Server/Сервер (режим работы на cервере)** – выполнение уже собранных webpack-ом скриптов на стороне NodeJS.

## Состав проекта

Шаблон проекта Shell содержит директории:

* **config** – файлы с конфигурацией сборки проекта (см. [Параметры сборки](#build-config))
* **src** – основной код проекта:
  * **app-settings-shell** – настройки в режиме выполнения (см. [Настройки в режиме выполнения](#realtime-settings));
  * **constants** – константы для проекта Shell;
  * **client** – скрпиты с для формирования разметки – используется как на клиенте, так и при SSR;
  * **server** – скрипты для создания серверной части приложения;
  * **share** – скрипты общего назначения;
  * **types** – дополнительные типы данных;
  * **global.d.ts** – файл для принудительной типизации.

## Параметры сборки {#build}

### Варинаты запуска {#build-variants}

Запуск проекта осуществляется посредством команды
> npm run \<command\>

Shell предоставляет следующий набор способов запуска и сборки:

* **start** – основной способ запуска проекта в режиме разработчика

|Возможность|Доступность|
|:-|:-:|
|SSR|–|
|HotReload|+|

* **start:server** – запуск проекта в режиме разработчика с поддержкой SSR

|Возможность|Доступность|
|:-|:-:|
|SSR|+|
|HotReload|–|

* **build** / **build:server:prod** – очистка папки с результатом сборки и сборка проекта под прод
* **build:server:client:prod** – сборка клиентской части под прод
* **build:server:server:prod** – сборка серверной части под прод
* **build:client** – сборка клиентской части в режиме разработки
* **build:server** – сборка серверной части в режиме разработки
* **node:serve** – запуск проекта
* **clean** – очистка папки с результатом сборки

### Конфигурация сборки {#build-config}

Конфигурация сборки осуществляется через файлы webpack.
Путь расположения файлов:
> /config

* **module-federation** – содержит исчерпывающий набор параметров для наcтройки ModuleFederation.
* **webpack.config._.js** – базовый конфигурационный файл (напрямую не используется при сборке).
* **webpack.config.client._.js** – базовый конфигурационный файл для сборки клиентской части проекта (напрямую не используется при сборке).
* **webpack.config.client.server._.js** – базовый конфигурационный файл для сборки клиентской части проекта, серверная часть которого собирается на Node (напрямую не используется при сборке).
* **webpack.config.client.server.local._.js** / **webpack.config.client.server.prod._.js** – конфигурационные файлы, основанные на *webpack.config.client.server._.js* (для сборки под разное окружение).
* **webpack.config.client.standalone._.js** – базовый конфигурационный файл для сборки клиентской части проекта без серверной части на Node.
* **webpack.config.client.standalone.dev._.js** / **webpack.config.client.standalone.local._.js** / **webpack.config.client.standalone.prod._.js** – конфигурационные файлы, основанные на *webpack.config.client.standalone._.js* (для сборки под разное окружение).
* **webpack.config.server._.js** – конфигурационный файл для сборки серверной части проекта на Node.

> *Сборка серверной части не означает использование технологии SSR. Для итогового развернутого стенда рекомендуется собирать проект именно с серверной частью, т.к. это способ имеет более расширенный функционал.*

### Конфигурация Module Fedration {#module-fedration-config}

QP8 Widget Platform Shell основана на технологии Module Fedration и использует различные способы подключения модулей на его основе.

Существует два базовых режима: статический и динамический.
Переключение режимов осуществляется через параметр **useDynamicModules** в файле настроек приложения в режиме выполнения ([Подробнее здесь](#realtime-settings)).

* **Статический**: в данном режиме настройка расположения модулей производится классическим способом через файл конфигурации **module-federation**.
* **Динамический**: в данном режиме вся необходимая информация о расположении модулей поступает из ответов API QP8.WidgetPlatform. В **module-federation** сам список модулей не указывается. Также необходимо модифицировать файл **app-settings-shell/static-wpc-modules** для конфигурирования контролов.

Динамический режим более гибок и удобен для работы. Он позволяет без перезапуска проекта Shell менять (с помощью контентных работ) в QP8.WidgetPlatform набор модулей и их физические адреса.
Статический способ подключения модулей имеет ряд ограничений, связанных с пересборкой проекта Shell для подключения нового комплекта контролов. Также исключительно в статическом режиме, при использовании SSR, серверный код приложения кеширует состояние модуля при первом его использовании, что приводит к необходимости перезапуска проекта Shell после каждого изменения в модуле (*мы работаем над решением данной проблемы*).

> *На данный момент при использовании SSR доступна только статическая подгрузка модулей (будет исправлено в следующих версиях).*

Основные настройки для технологии Module-Federation содержаться в файле **config/module-federation**. Их детальное описание выходит за рамки пояснений конфигурации пакета Widget Platform Shell.

#### Шаблон \*\*\*qp_widgets_platform_modules\*\*\*

При использовании статического подключения модулей и развертывания данного проекта в Kubernetes, возникает проблема с динамическим изменением пути для клиентской и серверной логики, в зависимости от площадки. Для обхода данной проблемы используется шаблон для замены **\*\*\*qp_widgets_platform_modules\*\*\*** на реальный адрес модуля.
В самом docker-файле производится замена шаблона на нужную строку.
Пример:

```dockefile
CMD sed -i -e 's#||\*\*\*qp_widgets_platform_modules\*\*\*||#'"<тут клиентский путь>"'#g' /dist/static/client/*.js; sed -i -e 's#||\*\*\*qp_widgets_platform_modules\*\*\*||#'"<тут серверный путь>"'#g' /dist/server/*.js; node /dist/server/main.js
```

#### Файл static-wpc-modules

В файле **app-settings-shell/static-wpc-modules** необходимо вносить изменения в случае, если проект использует статическую подгрузку модулей (*при динаимической подгрузке он игнорируется*). Данный файл содержит в себе необходимые импорты контролов для подключенных модулей, которые служат ориентирами для сборщика Webpack.
Пример файла static-wpc-modules:

```typescript
export const staticModules = {
  qp_widgets_platform_modules: {
    //pages
    start_page: () => import('qp_widgets_platform_modules/start_page'),
    text_page: () => import('qp_widgets_platform_modules/text_page'),
    //widgets
    html_widget: () => import('qp_widgets_platform_modules/html_widget'),
  },
};
```

В объeкте StaticModules перечислены имена модулей (в примере выше это *qp_widgets_platform_modules*). Внутри объeкта поля модуля перечислены имена контролов (страниц и виджетов), которые содержит этот модуль.

## Компоненты

### Шаблон HTML {#html-template}

Создание итоговой страницы начинается с базового шаблона. В зависимости от типа сборки, начальный шаблон может браться из:

* **src/client/public/index.html** – используется для сборки без серверной части ([Подробнее здесь](#build-config)).
* **src/server/views/client.ejs** – используется для сборки с серверной частью ([Подробнее здесь](#build-config)).

В Shell интегрирован пакет [Helmet](https://www.npmjs.com/package/react-helmet), позволяющий настроить метаданные страницы из подключенного модуля.

### Шаблон страницы {#layout}

Шаблон страницы расположен по адресу `src/client/components/layout/layout.tsx` и включает в себя базовый набор виджетных зон. Вы можете менять данный шаблон по своему усмотрению.

### Заглушка если не найдена страница {#not-found-page}

Для формирования структуры сайта используется [react-router-dom](https://www.npmjs.com/package/react-router-dom).
В случае, если в структуре сайта не была найдена страница, на экран будет отрендерен компонент по адресу `src/client/components/not-found-page/not-found-page.tsx`.

### Заглушка если не найден виджет {#not-found-component}

Если в процессе рендеринга не будет найден необходимый для отображения компонент, на экран будет выведен компонент по адресу `src/client/components/not-found-component/not-found-component.tsx`.

### Экран-заставка {#splash-screen}

Проект Shell поддерживает **splash-screen (экран-заставку)**, позволяющий увеличить скорость визуального отображения интерфейса для "тяжелых" сайтов. Необходимость в использовании splash-screen регулируется через параметр **activeSplashScreen** в настройках приложения в режиме выполнения ([Подробнее здесь](#realtime-settings)).
Вы можете поменять визуализацию компонента, изменив файл `src/client/components/splash-screen/splash-screen.tsx`.

### Ленивая загрузка компонентов {#lazy-loading}

В проекте Shell активно используется **lazy-loading (ленивая загрузка)** для компонентов. При её использовании в процессе загрузки отрисовывается заглушка, расположенная по адресу `src/client/components/loader/loader.tsx`.

## Другие возможности

### Sitemap {#sitemap-template}

Проект Shell, при сборке с серверной частью ([Подробнее](#build-config)), имеет функционал автоматического создания карты сайта для индексации поисковиков. Создание карты сайтов настраивается в настройках приложения в режиме выполнения ([Подробнее](#realtime-settings)) через параметр **activeSiteMap**.

Шаблон Sitemap-а, который будет возвращаться по адресу `/sitemap.xml`, находится по адресу `src/server/views/sitemap.ejs`.
Если необходимо внести дополнительные параметры в шаблон, то это можно сделать посредством редактирования файла `src/server/sitemap.ts`.

### Расширение выборки полей {#params-site-structure}

При доработках тех или иных частей Shell, может возникнуть необходимость в дополнительных параметрах, которые можно загрузить при получении структуры сайта QP8.WidgetPlatform c помощью WebAPI. Для подобных случаев предусмотрен файл `src/constants/site-structure-store-init-value.ts`.

```typescript
export const siteStructureStoreInitValue = {
  additionalFields: ['MetaKeywords', 'MetaDescription'],
};
```

В **siteStructureStoreInitValue** содержится перечень полей, которые будут подгружены при получении полной структуры сайта.
> *Здесь указываются поля только для случая получения полной структуры сайта, а не для виджетов и страниц. Для виджетов и страниц всегда приходит полный набор полей*.
> *Здесь нужно перечислять только необходимый минимум полей, т.к. эти поля будут передаваться для всего дерева, что может увеличить время загрузки*.

## On-screen {#on-screen}

Продукт QP8.WidgetPlatform содержит в себе удобный визуальный интерфейс для редактирования контента страницы. Включение функционала On-screen регулируется через параметр **onScreen** в настройках приложения в режиме выполнения ([Подробнее здесь](#realtime-settings)).
> *На данный момент поддерживается только режим Widgets*.

Данный функционал размечает зоны и виджеты на странице. Также, если разработчиком модуля предусмотрена разметка через компонент OnScreenArticle, будут выводиться зоны с контентами.

> *За отрисовку функционала, связанного в On-screen, отвечают компоненты из папки `src/client/components/on-screen`. Мы не рекомендуем их менять*.

## Настройки в режиме выполнения {#realtime-settings}

### Состав параметров-настроек

* **widgetsPlatform** – блок настройки подключения к QP8 Widget Platform WebAPI
  * **apiUrl** – адрес WebAPI виджетной платформы
  * **graphql** – блок настройки для GraphQL виджетной платформы
    * **apiUrl** – адрес GraphQL виджетной платформы
    * **apiKey** – apiKey GraphQL виджетной платформы
  * **dnsName** – DNS-имя сайта
  * **forcedConfigurationOfDynamicModules** – принудительная конфигурация для модулей; используется в режиме разработки
    * **<имя_контроллера>** – имя контроллера, который нужно принудительно перекрыть
      * **url** – url-адрес, где расположен модуль
      * **moduleName** – имя модуля
* **onScreen** – настройки для On-screen ([Подробнее здесь](#on-screen))
  * **active** – указывает Shell на необходимость использования On-screen
  * **adminSiteBaseUrl** – адрес On-screen API QP8.WidgetPlatform
  * **isStage** – режим использования (подробнее в документации по On-screen)
  * **availableFeatures** – режим использования; доступные значения: "Widgets", "A/B TESTS"
  * **mutationWatcherElementId** – ID рутового компонента, в который React рендерит контент
* **baseURL** – базовый URL
* **publicPath** – путь, по которому расположены файлы проекта.
* **activeSiteMap** (true/false) – нужно ли генерировать путь `/sitemap.xml`, по которому будет доступна карта сайта ([Подробнее здесь](#sitemap))
* **activeSplashScreen** (true/false) – нужно ли создавать лоадер, отображаемый после загрузки сайта на клиенте ([Подробнее здесь](#splash-screen))
* **useDynamicModules** (true/false) – нужно ли использовать динамическую загрузку модулей; false – используется статическая загрузка модулей ([Подробнее здесь](#module-fedration-config))
* **ssr** – блок настроек для серверного рендеринга
  * **active** – указывает Shell на необходимость серверного рендеринга
  * **ttl** – время кеширования страниц в секундах на сервере

Пример настроек:

```json
{
  "widgetsPlatform": {
    "apiUrl": "https://wp-api.demositerus.qsupport.ru"
    "graphql": null,
    "dnsName": "wp-template.qsupport.ru",
    "forcedConfigurationOfDynamicModules": { }
  },
  "baseURL": "/",
  "activeSiteMap": true,
  "activeSplashScreen": false,
  "useDynamicModules": false,
  "ssr": {
    "active": true,
    "ttl": 30
  }
}
```

### Состав файлов-настроек

Путь расположения файлов с настройками проекта Shell:
> \src\app-settings-shell

Shell поддерживет раздельные настройки для сервера и клиента и позволяет вынести общие настройки в отдельный файл.

По умолчанию доступно:

* **base-settings.json** – базовый список параметров, единый для клиента и сервера
* **client-settings.json** – уникальный список параметров для клиента
* **server-settings.json** – уникальный список параметров для сервера

При запуске проекта на NodeJS файлы настроек проходят этап "deep merge"/"глубокого объединения". Shell генерирует клиентский путь `/settings.json` для уже объединенного (из base-settings.json и client-settings.json) файла. Для SSR Shell возвращает объединенные настройки (из base-settings.json и server-settings.json) в параметры для рендеринга.

Все настройки читаются в реальном времени при работе приложения, что позволяет заменять файлы в итоговой сборке в зависимости от стенда и переиспользовать собранные бандлы.

*Отдельные настройки позволяют задать различные apiUrl (внешний и внутренний), что широко используется при развороте проекта в Docker-контенейре внутри Kubernetes.*

Типизированные интерфейсы для настроек расположены по адресу `src/share/app-settings-shell.ts`.

## Создание подстраниц

Проект Shell сам создает роутеры на основании информации, полученной из WebAPI. Дерево сайта строится с использованием пакета **react-router-dom**.

Само дерево сайта настраивается в QP8 Widget Platform контент-редактором. Внесение изменений в данную структуру не рекомендуется.
Исключением из данной ситуации являются "контентные страницы". Например, cтраница конкретной новости, доступная по отдельному URL. React-router-dom для этого случая предполагает использование параметризованных URL. Например:
> /news/:index

По умолчанию, при построении дерева, нет возможности узнать о необходимости поддержки параметризованных URL.

На данный момент есть возможность расширить дерево дополнительными параметрами. Для этого нужно в конструкторе класса **SiteStructureStore** передать значение maxDynamicPathLevel, которое для каждого адреса дополнительно увеличивает количество параметризованных частей URL.

Однако для использования вложенных URL в файле компонента модуля необходимо создать функцию **allowedSubpage** и вернуть true. Это укажет Shell, что на данной странице поддерживаются вложенные подстраницы.

## Передача информации через qp8-widget-platform-bridge {#bridge}

Подключенные модули могут получить дополнительную информацию из проекта Shell посредством использования проекта [qp8-widget-platform-bridge](https://github.com/QuantumArt/QA.WidgetPlatform.Bridge) и хуков из него.

* **useAbstractItem** — хук, позволяющий получить системную информацию об узле структуры сайта ([Подробнее здесь](#bridge-abstract-item)).
* **useWPRoutesStore** — хук, позволяющий получить дополнительную информацию о путях, где расположена страница или виджет ([Подробнее здесь](#bridge-routes-store)).
* **useWPGraphQLClient** — хук, позволяющий получить «стандартизированный» клиент GraphQL ([Подробнее здесь](#bridge-graphql)).
* **useEventBusStore** — хук, позволяющий получить «стандартизированную» реализацию шины событий для обмена информацией между виджетами ([Подробнее здесь](#bridge-event-bus)).

### AbstractItem {#bridge-abstract-item}

Внутри модуля можно вызвать хук useAbstractItem. Данный хук позволяет получить системную информацию об узле структуры сайта. Это может быть как страница, так и виджет. Возвращается следующий интерфейс:

```typescript
export interface IAbstractItem {
  readonly id: number; 
  readonly alias: string;
  readonly nodeType: string;
  readonly children: IAbstractItem[];
  readonly sortOrder: number;
}
```

Shell имеет две различные реализации для AbstractItem в зависимости от предназначения AbstractItem. Это может быть страница или виджет:

* Страница — класс PageItemStore, расположенный по адресу `src/client/stores/abstract-item/widget-item-store.ts`.
* Виджет — класс WidgetItemStore, расположенный по адресу `src/client/stores/abstract-item/widget-item-store.ts`.

### WPRoutesStore {#bridge-routes-store}

Внутри модуля можно вызвать хук useWPRoutesStore. Данный хук позволяет получить дополнительную информацию о путях, где расположена страница или виджет. Возвращается следующий интерфейс:

```typescript
export interface IWPRoutesStore {
  getBreadcrumbs(): BreadcrumbItem[];
  getSiteMap(maxDeep?: number): PageNode[];
  getTailUrl(): string;
}
```

Реализация интерфейса в Shell расположена по адресу `src/client/stores/wp-routes/wp-routes-store.ts`.

Все методы используют внутренние реализации из проекта [qp8-widget-platform-shell-core](https://github.com/QuantumArt/QA.WidgetPlatform.Shell.Core). В случае необходимости их можно заменить на собственные или изменить параметры вызова методов из [qp8-widget-platform-shell-core](https://github.com/QuantumArt/QA.WidgetPlatform.Shell.Core).

* **getBreadcrumbs** — возвращает список хлебных крошек с названием страниц и URL этой страницы.
* **getSiteMap** — возвращает структуру сайта.
* **getTailUrl** — необходим для случаев, когда страница не имеет точного адреса. Например, *new/details/123/tab-1*. Сама страница в данном случае может быть расположена по пути *new/details* в структуре сайта. В таком случае метод вернет *123/tab-1* из адресной строки.

### GraphQL {#bridge-graphql}

Внутри модуля можно вызвать хук useWPGraphQLClient. Данный хук позволят получить общий клиент GraphQL. В шаблоне используется реализация клиента GraphQL на основе [ApolloClient](https://github.com/apollographql/apollo-client).
Реализация шаблона находится по адресу `src/share/stores/graphql-client/graphql-client.ts`

### Event bus {#bridge-event-bus}

Внутри модуля можно вызвать хук useEventBusStore. Данный хук позволят получить общий клиент шины событий для обмена информацией между виджетами. В шаблоне используется реализация на основе [EventBus](https://github.com/bcerati/js-event-bus).
Создание экземпляра шины происходит в файлах:

> `src/server/prepare-server-app.ts`
> `src/client/bootstrap.tsx`
